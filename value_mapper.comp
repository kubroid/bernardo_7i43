component dia_mapper "Diapason Mapper";

description """Diapason Mapper. Implements the following mapping function:

out(x) = ((x-x1)*(y2-y1)/(x2-x1)+y1)
Where x1 < x < x2

So, it maps one diapason of values to another
""";

pin in unsigned in "Input value";
pin out unsigned out "Mapped value";
pin in bit enable = 1 "Mapper enable. When false, the in is passed to out without any calculations.";

function _;

option extra_setup;

license "GPL";
;;
//#include <stdio.h>
//#include <map>

typedef struct {
	int commanded;
	int measured;
} data;

data raw_data[] = {\
	/*commanded, measured*/\
	{       100,      180 },\
	{       150,      190 },\
	{       200,      350 },\
	{       300,      400 },\
	{       400,      450 },\
	{       500,      510 },\
	{       600,      580 },\
	{       700,      650 },\
	{       800,      700 },\
};

#define ARR_SIZE(a) (sizeof(a)/sizeof((a)[0]))

int comparer(const void *_v1, const void *_v2)
{
	data *v1 = (data*)_v1;
	data *v2 = (data*)_v2;
	if(v1->measured == v2->measured)
		return 0;
	else if(v1->measured > v2->measured)
		return 1;
	return -1;
}

EXTRA_SETUP()
{
//    qsort(raw_data, (sizeof(raw_data)/sizeof(raw_data[0])), sizeof(data), comparer);

    return(0);
}


int calc(int x)
{
	if(raw_data[0].measured > x) // X too low
		return raw_data[0].commanded;
	
	int i, j;

	for(i = 0; i < ARR_SIZE(raw_data); ++i)
	{
		j = i + 1;
		if(j == ARR_SIZE(raw_data))	// x tool high
			return raw_data[i].commanded;

		if(raw_data[j].measured >= x)
			break;
	};

	int x1, x2, y1, y2;
	y1 = raw_data[i].commanded;
	y2 = raw_data[j].commanded;
	x1 = raw_data[i].measured;
	x2 = raw_data[j].measured;

	if(x2 == x1)	// prevent divide by zero
	{
		return y1;
	}

	return ((int)(x-x1)*(y2-y1)/(x2-x1)+y1);
}

FUNCTION(_)
{
	int x = in;
	if(enable)
	{
		out = x;
		return;
	}
	out = calc(x);
}
